name: 'Build Lectures'
description: 'Builds QuantEcon lectures using Jupyter Book'
author: 'QuantEcon'

# NOTE: For caching, use the dedicated cache actions:
#   - build-jupyter-cache: Weekly cache generation on main branch
#   - restore-jupyter-cache: Read-only restore for PR workflows

inputs:
  builder:
    description: 'Jupyter Book builder to use (html, pdflatex, custom --custom-builder=jupyter)'
    required: false
    default: 'html'
  source-dir:
    description: 'Source directory containing lectures'
    required: false
    default: 'lectures'
  output-dir:
    description: 'Output directory for build artifacts'
    required: false
    default: './'
  extra-args:
    description: 'Extra arguments to pass to jupyter-book build'
    required: false
    default: '-W --keep-going'
  html-copy-pdf:
    description: 'Stage PDF from _build/latex/ into _build/html/_pdf/ before HTML build so theme can detect and enable downloads (requires prior pdflatex build)'
    required: false
    default: 'false'
  html-copy-notebooks:
    description: 'Stage notebooks from _build/jupyter/ into _build/html/_notebooks/ before HTML build so theme can detect and enable downloads (requires prior jupyter build)'
    required: false
    default: 'false'
  upload-failure-reports:
    description: 'Upload execution reports as artifacts when build fails'
    required: false
    default: 'false'
  failure-artifact-name:
    description: 'Custom name for failure report artifact (default: execution-reports-{builder})'
    required: false
    default: ''

outputs:
  build-path:
    description: 'Path to the build output directory'
    value: ${{ steps.build.outputs.build-path }}

runs:
  using: "composite"
  steps:
    - name: Stage PDF for HTML build
      if: inputs.builder == 'html' && inputs.html-copy-pdf == 'true'
      shell: bash
      run: |
        echo "::group::Stage PDF for HTML build"
        PDF_SOURCE="${{ inputs.output-dir }}/_build/latex"
        PDF_DEST="${{ inputs.output-dir }}/_build/html/_pdf"
        
        if [ -d "$PDF_SOURCE" ]; then
          mkdir -p "$PDF_DEST"
          find "$PDF_SOURCE" -name "*.pdf" -exec cp {} "$PDF_DEST/" \;
          echo "Staged PDFs in $PDF_DEST (Jupyter Book will detect and enable downloads):"
          ls -lh "$PDF_DEST" || echo "No PDFs found"
        else
          echo "::warning::PDF source directory not found: $PDF_SOURCE"
          echo "Run pdflatex builder before html builder with html-copy-pdf"
        fi
        echo "::endgroup::"

    - name: Stage notebooks for HTML build
      if: inputs.builder == 'html' && inputs.html-copy-notebooks == 'true'
      shell: bash
      run: |
        echo "::group::Stage notebooks for HTML build"
        NB_SOURCE="${{ inputs.output-dir }}/_build/jupyter"
        NB_DEST="${{ inputs.output-dir }}/_build/html/_notebooks"
        
        if [ -d "$NB_SOURCE" ]; then
          mkdir -p "$NB_DEST"
          find "$NB_SOURCE" -name "*.ipynb" -exec cp {} "$NB_DEST/" \;
          NB_COUNT=$(find "$NB_DEST" -name "*.ipynb" | wc -l)
          echo "Staged $NB_COUNT notebooks in $NB_DEST (Jupyter Book will detect and enable downloads)"
        else
          echo "::warning::Notebook source directory not found: $NB_SOURCE"
          echo "Run jupyter builder before html builder with html-copy-notebooks"
        fi
        echo "::endgroup::"

    - name: Build lectures
      id: build
      shell: bash -l {0}
      run: |
        echo "Building with builder: ${{ inputs.builder }}"
        
        # Set build command based on builder type
        if [ "${{ inputs.builder }}" = "html" ]; then
          BUILD_CMD="jb build ${{ inputs.source-dir }} --path-output ${{ inputs.output-dir }} ${{ inputs.extra-args }}"
        elif [ "${{ inputs.builder }}" = "pdflatex" ]; then
          BUILD_CMD="jb build ${{ inputs.source-dir }} --builder pdflatex --path-output ${{ inputs.output-dir }} -n ${{ inputs.extra-args }}"
        elif [ "${{ inputs.builder }}" = "jupyter" ]; then
          BUILD_CMD="jb build ${{ inputs.source-dir }} --path-output ${{ inputs.output-dir }} --builder=custom --custom-builder=jupyter -n ${{ inputs.extra-args }}"
        else
          # Custom builder
          BUILD_CMD="jb build ${{ inputs.source-dir }} --builder ${{ inputs.builder }} --path-output ${{ inputs.output-dir }} ${{ inputs.extra-args }}"
        fi
        
        echo "::group::Build Command"
        echo "$BUILD_CMD"
        echo "::endgroup::"
        
        # Execute build and capture exit code
        set +e
        eval $BUILD_CMD
        BUILD_EXIT_CODE=$?
        set -e
        
        # Set output paths regardless of success/failure
        if [ "${{ inputs.builder }}" = "html" ]; then
          echo "build-path=${{ inputs.output-dir }}/_build/html" >> $GITHUB_OUTPUT
        elif [ "${{ inputs.builder }}" = "pdflatex" ]; then
          echo "build-path=${{ inputs.output-dir }}/_build/latex" >> $GITHUB_OUTPUT
        elif [ "${{ inputs.builder }}" = "jupyter" ]; then
          echo "build-path=${{ inputs.output-dir }}/_build/jupyter" >> $GITHUB_OUTPUT
        else
          echo "build-path=${{ inputs.output-dir }}/_build" >> $GITHUB_OUTPUT
        fi
        
        # Exit with build exit code
        exit $BUILD_EXIT_CODE

    - name: Report build failure
      if: failure()
      shell: bash
      run: |
        echo ""
        echo "::error::âŒ BUILD FAILED - Jupyter Book build encountered errors"
        echo ""
        echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
        echo "â•‘                    BUILD FAILURE SUMMARY                       â•‘"
        echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "  Builder:   ${{ inputs.builder }}"
        echo "  Source:    ${{ inputs.source-dir }}"
        echo "  Output:    ${{ inputs.output-dir }}/_build"
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        if [ "${{ inputs.upload-failure-reports }}" = "true" ]; then
          echo "ğŸ“¦ Execution reports will be uploaded as artifact: execution-reports-${{ inputs.builder }}"
          echo ""
          echo "To debug this failure:"
          echo "  1. Download the 'execution-reports-${{ inputs.builder }}' artifact from this workflow run"
          echo "  2. Check _build/${{ inputs.builder }}/reports/ for notebook execution logs"
          echo "  3. Check _build/.jupyter_cache/ for cached notebook states"
          echo ""
        else
          echo "ğŸ’¡ Tip: Enable 'upload-failure-reports: true' to get execution reports for debugging"
          echo ""
        fi

    - name: Upload execution reports on failure
      if: inputs.upload-failure-reports == 'true' && failure()
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.failure-artifact-name != '' && inputs.failure-artifact-name || format('execution-reports-{0}', inputs.builder) }}
        path: |
          ${{ inputs.output-dir }}/_build/html/reports
          ${{ inputs.output-dir }}/_build/latex/reports
          ${{ inputs.output-dir }}/_build/jupyter/reports
          ${{ inputs.output-dir }}/_build/.jupyter_cache
        if-no-files-found: ignore
        retention-days: 7

    - name: Display Build Info
      if: success()
      shell: bash
      run: |
        echo "::group::Build Summary"
        echo "Builder: ${{ inputs.builder }}"
        echo "Source: ${{ inputs.source-dir }}"
        echo "Output: ${{ steps.build.outputs.build-path }}"
        if [ "${{ inputs.builder }}" = "html" ]; then
          echo "PDF copied to HTML: ${{ inputs.html-copy-pdf }}"
          echo "Notebooks copied to HTML: ${{ inputs.html-copy-notebooks }}"
        fi
        echo "::endgroup::"
        
        echo "::group::Build Artifacts"
        ls -lh ${{ steps.build.outputs.build-path }} || echo "Build directory not found"
        echo "::endgroup::"

branding:
  icon: 'book-open'
  color: 'purple'
